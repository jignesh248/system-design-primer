[Sharding Pinterest: How we scaled our MySQL fleet](https://medium.com/@Pinterest_Engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f
)

Key Takeaway : 
- several NOSQL technologies failed catastrophically for Pinterest
- Uses MySQL queries to support ordering, range queries and transactions, ditching immature tech
- Dump to S3 for OLAP(Map/Reduce)
- master master configuration for MYSQL, read/write goes to master to avoid replication bugs
- each master has a slave for backup host for primary host failure
- each master has many shards as DBs, data never moves outside of shard, if data grows beyond a shard, move around the 
whole shard data to instance with larger storage
- config table for range mapping to master/slave
- config table only changes when shards are moved around or a host is replaced. When master dies, slave is promoted and 
then new slave is provisioned. The config lives in ZooKeeper and, on update, is sent to services that maintain the MySQL shard.
- Each shard contains same set of tables: pins, boards, users_has_pins, users_likes_pins, pin_liked_by_user, etc
- ID = (shard ID << 46 bits) | (type ID << 36 bits) | (local ID<<10 bits) | (reserved for future << 2 bits)
- type ID : type of the containing data
- reserve bits are worth their weight in gold
- eg. query
```
conn = MySQLdb.connect(host=”MySQL012A”)
conn.execute(“SELECT data FROM db03429.pins where local_id=7075733”)
```
- types of data: objects and mappings
- Object Tables : Pins, users, boards and comments
- Object have an ID (the local ID, an auto-incrementing primary key) and a blob of data that contains a JSON
- delete are done with boolean "active" flag in table
- Mapping tables :
eg. board to the Pins
columns: a 64 bit ‘from’ ID, a 64 bit ‘to’ ID and a sequence ID.
live on the shard of the ‘from’ ID
```
CREATE TABLE board_has_pins (
  board_id INT,
  pin_id INT,
  sequence INT,
  INDEX(board_id, pin_id, sequence)
) ENGINE=InnoDB;
```
- Mapping tables are unidirectional
- sequence ID = unix timestamp
- lookup :
```
SELECT pin_id FROM board_has_pins 
WHERE board_id=241294561224164665 ORDER BY sequence 
LIMIT 50 OFFSET 150
```
an application layer join (board_id -> pin_ids -> pin objects).
 One awesome property of application layer joins is that you can cache the mapping separate from the object. 
 eg. pin_id -> pin object cache in a memcache cluster
  and board_id -> pin_ids in a redis cluster. 
  
 allows to choose the right technology to best match the object being cached.
 
- 3 ways to add more capacity
1. upgrade the machines (more space, faster hard drives, more RAM, whatever your bottleneck is)
2. open up new ranges for shards. Initially, 4,096 shards were created even though shard ID is 16 bits (64k total shards). 
create new MySQL servers with shards 4,096 to 8,191 and started filling those.
3. The final way we add capacity is by moving some shards to new machines. 
MySQL001A - shards 0 to 511, 
new master-master pair with the next largest names 
MySQL009A and B 256-511 from shard MySQL001A

- new UUIDs = shard ID + type ID + MySQL autogenerated local ID
 
- No ALTER queries, for pinterest it was 1 in 3 years.

- To add new fields to objects, simply teach your services that your JSON schema has a few new fields. 
 For backward compatibility use default value when you deserialize JSON from an object without your new field
- If you need a mapping table, create the new mapping table and start filling it up whenever you want. 
When you’re done, ship your product!
- mod shard : For non-ID lookups eg. Facebook IDs to Pinterest IDs 
other eg. IP addresses, username and email

it is much like the shard system already described, but look up supports arbitrary input. 
Input is hashed and modded against the total number of shards that exist in the system. 
The result is the shard the data will live on / already lives on. 

For example:
shard = md5(“1.2.3.4") % 4096
shard in this case would be 1524. 

We maintain a config file similar to the ID shard:

[{“range”:    (0,  511), “master”: “msdb001a”, “slave”: “msdb001b”},
  {“range”:  (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”},
  {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”},
…]

eg. to find data about IP address 1.2.3.4 :

```
conn = MySQLdb.connect(host=”msdb003a”)
conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip='1.2.3.4'”)
```

Cons : loss of spacial locality of ID shard

- best to represent objects in your system with immutable IDs.
That way you don’t have to update lots of references when, for instance, a user changes their username.

- Used https://github.com/binarydud/pyres for writing scripts to import data to new system.

- System described does'nt give Atomicity, Isolation or Consistency in all cases
- Build ACID based architecture as and when needed for new sub-systems when required.

###### Note(Updated 18-02-2019) : 
- instead of 4096 I guess it is better to use hashring based on Consistent Hashing, with 360 degree, and degree ranges be mapped to 
shard ID's, so that adding new shards won't break the process and still mod shard data can be spread to new shards being
added
- Pinterest didn't use auto-failover for sure uptil Aug 17, 2015
- What ever data modelling that was used here, if mapping table isn't used with database level joins I guess the same
could have been achieved with DynamoDB, though that one alter table would have cost fortune it was supposed to be done
in short period of time.





 